\subsubsection{Definition}
Jede natuerliche Zahl 'n' kann als Produkt von Primzahlen 'p', den Primfaktoren, dargestellt werden. Dies nennt man Primfaktorzerlegung. Die Reihenfolge der einzelnen Primfaktoren 'p' spielt wie bei jeder anderen Multiplikation keine Rolle. Fuer den Fall, dass 'n' eine Primzahl ist, ist sie ihr einziger Faktor. Bei der Primfaktorzerlegung koennen Faktoren mehrfach auftreten. Diese kann man Exponentiell zusammenfassen. Kanonische Primfaktorzerlegung wird eine Primfaktorzerlegung genannt, sobald die einzelnen Faktoren nach der Hoehe ihrer Basis aufsteigend geordnet sind ('pk < pk+1').
\subsubsection{Beispiele}
%*Beispiele fuer Primfaktorzerlegung*
\begin{equation}
14 = 2 * 7
\end{equation}
\begin{equation}
69 = 3 * 23
\end{equation}
\begin{equation}
666 = 2 * 3 * 3 * 27
\end{equation}
\begin{equation}
1337 = 7 * 191
\end{equation}
Und in der Kanonischen Primfaktorzerlegung:
\begin{equation}
666 = 2 * 3^2 * 27
\end{equation}
\subsubsection{Faktorisierungsverfahren}
Bis heute gibt es kein effizientes Faktorisierungsverfahren. Die einfachste Moeglichkeit ist es, die zu faktorisierende, natuerliche Zahl 'n' durch alle Primzahlen von Zwei bis zur Wurzel von 'n' zu teilen, bis man einen Teiler gefunden hat, bei dem das Ergebnis keinen Rest hat. Man merkt sich nun diesen Teiler, also den ersten Primfaktor, und fuehrt nun fort, ersetzt jedoch 'n' mit dem gerade errechneten Quotienten. Fortgefuerht wird dies, solange 'n' keine Primzahl ist. Ist sie es, hat man seine natuerliche Zahl 'n' erfolgreich ausschliesslich mit Primzahlen faktorisiert.
\subsubsection{Programmbeispiel}
\begin{lstlisting}
size_t teile(size_t zahl)
{
	size_t teiler = 2;
	size_t x = sqrt(zahl);
	while (zahl % teiler != 0)
	{
		if (teiler >= x)
		{
			return zahl;
		}
		else
		{
			++teiler;
		}
	}

	return teiler;
}

std::string primfaktorzerlegung(size_t zahl)
{
	std::stringstream ss;
	size_t teiler = 0;

	ss << zahl << " = ";

	while (zahl != 1)
	{
		teiler = teile(zahl);
		ss << teiler;
		zahl = zahl / teiler;
		if (zahl != 1)
			ss << "*";
	}

	return ss.str();
}

void generatePrimeFactors(unsigned threadnum, std::map<size_t, std::string>* factors)
{
	std::cout << threadnum << std::endl;
	for (size_t i = threadnum; i < 0xFFFFFFF; i += 8)
	{
		factors->insert(std::pair<size_t, std::string>(i, primfaktorzerlegung(i)));
	}
}

int main(  )
{
	std::map<size_t, std::string> factors;
	std::thread* threads = new std::thread[8];
	for (unsigned i = 0; i < 8; ++i)
	{
		threads[i] = std::thread(generatePrimeFactors, i, &factors);
	}

	for (unsigned i = 0; i < 8; ++i)
	{
		threads[i].join();
	}

	delete[] threads;

	system("pause");

    return 0;
}
\end{lstlisting}